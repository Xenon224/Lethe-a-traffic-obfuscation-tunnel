# Lethe ðŸŒŠ
> * Lethe is the river of oblivion. Those who drank from it forgot everything.*

A traffic obfuscator that makes your internet activity invisible to your ISP â€” not just encrypted, but disguised as normal HTTPS traffic to defeat deep packet inspection (DPI).

**Built from in Python**

---

## What it does

Your ISP normally sees:
- Every domain you visit (via SNI in TLS handshakes)
- DNS queries revealing your destinations
- VPN traffic patterns that are trivially identifiable

With Lethe running, your ISP sees:
- Encrypted HTTPS traffic to one server you own
- A valid TLS certificate from Let's Encrypt
- Normal looking packet sizes and timing
- Nothing else

---

## How it works

```
Browser
  â”‚  SOCKS5 (destination extracted here)
  â–¼
Local Proxy (127.0.0.1:1080)
  â”‚  X25519 key exchange + ChaCha20-Poly1305 encryption
  â–¼
Your VPS (looks like HTTPS to ISP)
  â”‚  Decrypt, forward to real destination
  â–¼
Actual Website
```

### The stack
- **SOCKS5 proxy** â€” intercepts all browser traffic at the socket level
- **X25519 Diffie-Hellman** â€” fresh encryption key negotiated every session, perfect forward secrecy
- **ChaCha20-Poly1305** â€” authenticated encryption for all tunnel traffic (same as Signal/WireGuard)
- **TLS 1.3** â€” wraps the entire tunnel so it looks like normal HTTPS
- **asyncio** â€” handles hundreds of concurrent connections on a single thread

---

## Setup

### Prerequisites
- Python 3.10+
- A VPS (DigitalOcean, Vultr, etc.) running Ubuntu 22.04
- A domain name pointing to your VPS
- `cryptography` library: `pip install cryptography`

### VPS Setup

SSH into your VPS and run:

```bash
# Install dependencies
apt update && apt install python3-pip certbot -y
pip3 install cryptography

# Get a TLS certificate
certbot certonly --standalone -d yourdomain.com

# Certbot saves certs to:
# /etc/letsencrypt/live/yourdomain.com/fullchain.pem
# /etc/letsencrypt/live/yourdomain.com/privkey.pem
# Update these paths in server/relay.py â†’ main() if your domain differs

# Clone the repo
git clone https://github.com/you/lethe
cd lethe

# Start the relay
python3 server/relay.py
```

### Client Setup

```bash
git clone https://github.com/you/lethe
cd lethe
pip install cryptography

# Configure your VPS details
python main.py setup

# Start the proxy
python main.py start
```

Then set your browser to use SOCKS5 proxy at `127.0.0.1:1080`.

---

## Commands

```bash
python main.py setup    # configure VPS IP, domain, ports
python main.py start    # start the local proxy and tunnel
python main.py status   # check if proxy and VPS are reachable
```

---

## Security design

| Property | Implementation |
|---|---|
| Encryption | ChaCha20-Poly1305 (256-bit) |
| Key exchange | X25519 ECDH |
| Forward secrecy | Fresh keypair every connection |
| Transport disguise | TLS 1.3 with real certificate |
| DNS privacy | All DNS resolved on VPS, not locally |
| SNI privacy | Only VPS domain visible to ISP |

---

## Why not just use a VPN?

VPNs encrypt content but are trivially identifiable by ISPs through DPI â€” characteristic handshakes, uniform packet sizes, keepalive patterns, non-standard ports.

Lethe's tunnel is wrapped in real TLS with a legitimate certificate on port 443. To a network observer it's indistinguishable from HTTPS traffic to a web server you own. This is the same approach used by [Shadowsocks](https://shadowsocks.org/), which was built specifically to defeat Chinese ISP DPI.

---

## Project structure

```
lethe/
â”œâ”€â”€ main.py              # CLI entry point
â”œâ”€â”€ config.py            # generated by setup
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ proxy.py         # SOCKS5 proxy server
â”‚   â””â”€â”€ tunnel.py        # encrypted tunnel client
â”œâ”€â”€ server/
â”‚   â””â”€â”€ relay.py         # VPS relay server
â””â”€â”€ shared/
    â””â”€â”€ protocol.py      # packet format, encryption, key exchange
```

---

## What I learned building this

- How SOCKS5 works at the byte level and why it's protocol-agnostic
- How TLS SNI leaks destinations even over HTTPS
- How ISPs do deep packet inspection and what signatures they look for
- How X25519 Diffie-Hellman key exchange works and why it provides forward secrecy
- How to build async network servers in Python with asyncio
- How to frame TCP streams with length prefixes to preserve message boundaries
- Why ChaCha20-Poly1305 is the cipher of choice for modern encrypted tunnels

---

## Disclaimer

Built for educational purposes to understand network security, traffic analysis, and cryptography. Use responsibly and in accordance with your local laws.

---

